// Generated by CoffeeScript 1.12.7
(function() {
  var INIT_FLAG, INIT_MODE, OIDS, Promise, ZEROID, ZEROID_STRING, _path, asrev, assign, g, ref1, trim,
    slice = [].slice;

  _path = require("path");

  Promise = require("bluebird");

  g = require("nodegit");

  assign = Object.assign;

  ref1 = g.Repository, INIT_FLAG = ref1.INIT_FLAG, INIT_MODE = ref1.INIT_MODE;

  g.RepositoryInitOptions.fromObject = function(options) {
    var opt, result;
    opt = assign({}, g.Repository.INIT_DEFAULTS, options);
    result = new g.RepositoryInitOptions();
    result.flags = 0;
    if (!opt.reinit) {
      result.flags |= INIT_FLAG.NO_REINIT;
    }
    if (!opt.dotgit) {
      result.flags |= INIT_FLAG.NO_DOTGIT_DIR;
    }
    if (opt.description) {
      result.description = opt.description;
    }
    result.initialHead = opt.head ? "" + opt.head : "master";
    if (opt.origin) {
      result.originUrl = "" + opt.origin;
    }
    if (opt.workdir) {
      result.workdirPath = "" + opt.workdir;
    }
    if (opt.relative_gitlink) {
      result.flags |= INIT_FLAG.RELATIVE_GITLINK;
    }
    if (opt.bare) {
      result.flags |= INIT_FLAG.BARE;
    }
    if (opt.template) {
      result.flags |= INIT_FLAG.EXTERNAL_TEMPLATE;
      result.templatePath = opt.template;
    }
    if (opt.mkdirp || opt.mkdir) {
      result.flags |= INIT_FLAG.MKDIR;
    }
    if (opt.mkdirp) {
      result.flags |= INIT_FLAG.MKPATH;
    }
    result.mode = 0;
    switch (opt.shared) {
      case "umask":
        result.mode = 0;
        break;
      case "group":
        result.mode = 0x2775;
        break;
      case "all":
        result.mode = 0x2777;
        break;
      default:
        result.mode |= ("" + result.mode) | 0;
    }
    return result;
  };

  OIDS = new Map();

  OIDS.set(g.AnnotatedCommit, function(commit) {
    return commit.id();
  });

  OIDS.set(g.Blob, function(blob) {
    return blob.id();
  });

  OIDS.set(g.Commit, function(commit) {
    return commit.id();
  });

  OIDS.set(g.DiffFile, function(diff) {
    return diff.id();
  });

  OIDS.set(g.IndexEntry, function(entry) {
    return entry.id;
  });

  OIDS.set(g.Note, function(node) {
    return node.id();
  });

  OIDS.set(g.Object, function(o) {
    return o.id();
  });

  OIDS.set(g.OdbObject, function(o) {
    return o.id();
  });

  OIDS.set(g.Oid, function(o) {
    return o;
  });

  OIDS.set(g.RebaseOperation, function(op) {
    return op.id;
  });

  OIDS.set(g.Reference, function(ref) {
    return ref.target();
  });

  OIDS.set(g.Tag, function(tag) {
    return tag.id();
  });

  OIDS.set(g.Tree, function(tree) {
    return tree.id();
  });

  OIDS.set(g.TreeEntry, function(entry) {
    return entry.oid;
  });

  ZEROID_STRING = (new Array(40)).join("0");

  ZEROID = g.Oid.ZERO = g.Oid.fromString(ZEROID_STRING);

  g.Oid.fromAnything = function(item) {
    if (OIDS.has(item.constructor)) {
      return OIDS.get(item.constructor)(item);
    } else {
      return g.Oid.fromString(("" + item) || ZEROID_STRING);
    }
  };

  g.Repository.INIT_DEFAULTS = Object.freeze({
    bare: true,
    reinit: true,
    template: null,
    mkdir: true,
    mkdirp: false,
    dotgit: true,
    head: null,
    workdir: null,
    origin: null,
    relative_gitlink: false
  });

  g.Repository.OPEN_DEFAULTS = Object.freeze({
    bare: false,
    search: true,
    crossfs: false
  });

  g.Repository._open = g.Repository.open;

  g.Repository.open = function(path, options) {
    var ceilings, flags;
    if (options == null) {
      options = {};
    }
    ceilings = ([].concat(options.ceilings || "")).join(_path.delimiter);
    options = assign({}, g.Repository.OPEN_DEFAULTS, options);
    flags = 0;
    if (!options.search) {
      flags |= this.OPEN_FLAG.OPEN_NO_SEARCH;
    }
    if (options.bare) {
      flags |= this.OPEN_FLAG.OPEN_BARE;
    }
    if (options.crossfs) {
      flags |= this.OPEN_FLAG.OPEN_CROSS_FS;
    }
    return Promise.resolve(this.openExt(path, flags, ceilings));
  };

  g.Repository._init = g.Repository.init;

  g.Repository.init = function(path, options) {
    if (options == null) {
      options = {};
    }
    return Promise.resolve(this.initExt(path, g.RepositoryInitOptions.fromObject(options)));
  };

  asrev = g.Revparse.toSpec = function(value) {
    var branch, date, id, offset, path, ref, result, rev, search, tag, type, upstream;
    switch (typeof value) {
      case "string":
        return value;
      case "number":
        return "HEAD@{" + (value | 0) + "}";
      case "object":
        if (!value) {
          return "HEAD";
        } else if (value instanceof Date) {
          return "HEAD@{" + (value.toISOString()) + "}";
        } else {
          id = value.id, rev = value.rev, tag = value.tag, ref = value.ref, branch = value.branch, date = value.date, path = value.path, offset = value.offset, search = value.search, upstream = value.upstream, type = value.type;
          result = "" + (id || rev || tag || ref || branch || 'HEAD');
          if (upstream && ("" + branch) === result) {
            result = branch + "@{upstream}";
          }
          if (offset) {
            result = result + "@{" + (offset | 0) + "}";
          }
          if (date) {
            result = result + "@{" + date + "}";
          }
          if (path) {
            result = result + ":" + (path.replace(/^\/+/, ''));
          } else if (search) {
            result = result + ":/" + search;
          } else if (type) {
            result = result + "^{" + type + "}";
          }
          return result;
        }
    }
  };

  g.Revparse._single = g.Revparse.single;

  g.Revparse.single = function(repo, where) {
    return g.Revparse._single(repo, this.toSpec(where));
  };

  assign(g.Repository.prototype, {
    headRefName: function() {
      if (this.isEmpty()) {
        return this.head()["catch"](function(err) {
          return err.message.replace(/.*'([^']+)'.*/, '$1');
        });
      } else {
        return this.head().then(function(head) {
          var name;
          name = head.name();
          head.free();
          return name;
        });
      }
    },
    commit: function(options) {
      var author, committer, message, parents, ref, tree;
      ref = options.ref, tree = options.tree;
      if (ref instanceof g.Reference) {
        ref = ref.name();
      } else if (ref) {
        ref = "" + ref;
      } else {
        ref = null;
      }
      if (!(tree instanceof g.Tree)) {
        tree = g.Tree.lookup(this, g.Oid.fromString("" + tree));
      }
      author = g.Signature.create(options.author);
      committer = g.Signature.create(options.committer);
      parents = Promise.resolve((options.parents || []).filter(function(a) {
        return a;
      })).map((function(_this) {
        return function(parent) {
          if (parent instanceof g.Commit) {
            return parent;
          } else {
            return _this.getCommit("" + parent);
          }
        };
      })(this));
      message = options.message || ("Commit " + (new Date()));
      return Promise.all([ref, tree, parents]).then((function(_this) {
        return function(arg) {
          var parent_count, parents, ref, tree;
          ref = arg[0], tree = arg[1], parents = arg[2];
          if (author == null) {
            author = _this.defaultSignature();
          }
          if (committer == null) {
            committer = _this.defaultSignature();
          }
          parent_count = parents.length;
          return Promise.resolve(g.Commit.create(_this, ref, author, committer, null, message, tree, parent_count, parents));
        };
      })(this)).then((function(_this) {
        return function(oid) {
          return Promise.resolve(g.Commit.lookup(_this, oid));
        };
      })(this));
    },
    find: function(where) {
      return g.Revparse.single(this, where);
    },
    createRef: function(name, target, options) {
      var force, oid, sig;
      if (options == null) {
        options = {};
      }
      oid = g.Oid.fromAnything(target);
      force = options.force ? 1 : 0;
      sig = options.signature || Signature["default"](this);
      return Promise.resolve(g.Reference.create(this, name, oid, force, sig, message || ""));
    }
  });

  g.Blob.prototype.toJSON = function() {
    return {
      id: "" + (this.id()),
      size: "" + (this.rawsize()),
      binary: this.isBinary() ? true : false,
      filemode: "" + (this.filemode().toString(8))
    };
  };

  g.TreeEntry.prototype.toJSON = function() {
    return {
      id: this.oid(),
      path: this.path(),
      type: this.isBlob() ? "blob" : "tree",
      filename: this.filename(),
      attr: this.attr().toString(8)
    };
  };

  g.Tree.prototype.toJSON = function() {
    return {
      id: "" + (this.id()),
      type: "tree",
      path: typeof this.path === "string" ? this.path : void 0,
      entries: this.entries().map(function(entry) {
        return {
          id: "" + (entry.oid()),
          filename: "" + (entry.filename()),
          type: entry.isBlob() ? "blob" : "tree"
        };
      })
    };
  };

  trim = function(value) {
    if (typeof value === "string") {
      return value.replace(/(^[<\s]+|[\s>]+$)/g, "");
    } else {
      return value;
    }
  };

  g.Time.parse = function(date) {
    var d, offset, time;
    d = new Date(date);
    time = d.getTime();
    if (!time) {
      d = new Date();
      time = d.getTime();
    }
    offset = d.getTimezoneOffset();
    time = time / 1000 | 0;
    return {
      time: time,
      offset: offset
    };
  };

  g.Signature._create = g.Signature.create;

  g.Signature.create = function() {
    var args, date, email, name, offset, ref2, ref3, ref4, ref5, ref6, ref7, signature, time;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    switch (args.length) {
      case 4:
        name = args[0], email = args[1], time = args[2], offset = args[3];
        break;
      case 3:
        name = args[0], email = args[1], date = args[2];
        ref2 = g.Time.parse(date), time = ref2.time, offset = ref2.offset;
        break;
      case 2:
        signature = args[0], date = args[1];
        ref3 = g.Time.parse(date), time = ref3.time, offset = ref3.offset;
        if (typeof signature === "string") {
          ref4 = g.Signature.parse(signature), name = ref4.name, email = ref4.email;
        } else if (signature instanceof g.Signature) {
          name = signature.name();
          email = signature.email();
        } else if (typeof signature === "object") {
          name = signature.name, email = signature.email;
        }
        break;
      case 1:
        signature = args[0];
        if (signature instanceof g.Signature) {
          return signature;
        } else if (typeof signature === "string") {
          ref5 = g.Signature.parse(signature), name = ref5.name, email = ref5.email;
          ref6 = g.Time.parse(null), time = ref6.time, offset = ref6.offset;
        } else if (typeof signature === "object") {
          name = signature.name, email = signature.email, date = signature.date;
          ref7 = g.Time.parse(date), time = ref7.time, offset = ref7.offset;
        }
    }
    time = parseInt(time);
    offset = parseInt(offset);
    name = trim(name);
    email = trim(email);
    if (!(name && time && offset)) {
      throw new TypeError("Invalid signature arguments");
    }
    return g.Signature._create(name, email, time, offset);
  };

  g.Signature.parse = function(signature) {
    var email, m, name, ref2;
    m = ("" + signature).match(/^([^<]+)(?:<([^>]+)>)?$/);
    if (m == null) {
      throw new TypeError("Cannot parse signature");
    }
    ref2 = m.slice(1), name = ref2[0], email = ref2[1];
    return {
      name: name,
      email: email
    };
  };

  g.Signature.fromString = function(signature, date) {
    var email, name, offset, ref2, ref3, time;
    ref2 = this.parse(signature), name = ref2.name, email = ref2.email;
    ref3 = g.Time.parse(date), time = ref3.time, offset = ref3.offset;
    email = trim(email);
    name = trim(name);
    return this.create(name, email, time, offset);
  };

  g.Signature.prototype.getDate = function() {
    var d;
    d = new Date();
    d.setTime(this.when().time() * 1000);
    return d;
  };

  g.Signature.prototype.toJSON = function() {
    return {
      name: this.name(),
      email: this.email(),
      date: this.getDate()
    };
  };

  g.Commit.prototype.toJSON = function() {
    return {
      id: "" + (this.id()),
      type: "commit",
      tree: "" + (this.treeId()),
      parents: this.parents().map(function(p) {
        return "" + p;
      }),
      date: this.date(),
      committer: this.committer().toJSON(),
      author: this.author().toJSON(),
      message: "" + (this.message())
    };
  };

  g.Reference.find = function(repo, refname) {
    var ref;
    if (refname == null) {
      refname = "HEAD";
    }
    ref = this.isValidName(refname) ? this.lookup(repo, refname)["catch"](function() {
      return null;
    }) : this.dwim(repo, refname);
    return ref.then((function(_this) {
      return function(r) {
        if (r != null ? r.isSymbolic() : void 0) {
          refname = r.symbolicTarget();
          return _this.find(repo, refname)["catch"](function() {
            return r;
          });
        } else {
          return ref;
        }
      };
    })(this));
  };

  g.Tag.prototype.toJSON = function() {
    var ref2;
    return {
      id: "" + (this.id()),
      name: "" + (this.name()),
      target: "" + (this.targetId()),
      message: "" + (this.message()),
      tagger: "" + ((ref2 = this.tagger()) != null ? ref2.toJSON() : void 0),
      type: "" + (this.targetType())
    };
  };

  module.exports = g;

}).call(this);

