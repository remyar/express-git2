// Generated by CoffeeScript 1.12.7
(function() {
  var GitUpdateRequest, PassThrough, Promise, ZERO_PKT_LINE, _path, assign, pktline, ref1, ref2, requestStream, spawn, which;

  ref1 = require("../helpers"), requestStream = ref1.requestStream, assign = ref1.assign, spawn = ref1.spawn, pktline = ref1.pktline;

  which = require("shelljs").which;

  _path = require("path");

  Promise = require("bluebird");

  PassThrough = require("stream").PassThrough;

  ref2 = require("../stream"), GitUpdateRequest = ref2.GitUpdateRequest, ZERO_PKT_LINE = ref2.ZERO_PKT_LINE;

  module.exports = function(app, options) {
    var GIT_EXEC, headers;
    if (options == null) {
      options = {};
    }
    GIT_EXEC = (options != null ? options.git_executable : void 0) || which("git");
    headers = function(service, type) {
      if (type == null) {
        type = "result";
      }
      return {
        "Pragma": "no-cache",
        "Expires": (new Date("1900")).toISOString(),
        "Cache-Control": "no-cache, max-age=0, must-revalidate",
        "Content-Type": "application/x-git-" + (service.replace('git-', '')) + "-" + type
      };
    };
    app.post(":git_repo(.*).git/git-upload-pack", app.authorize("upload-pack"), function(req, res, next) {
      var git_repo, repositories;
      res.set(headers("upload-pack"));
      repositories = req.git.repositories;
      git_repo = req.params.git_repo;
      return repositories.openOrInit(git_repo).then(function(arg) {
        var args, repo;
        repo = arg[0];
        args = ["upload-pack", "--stateless-rpc", repo.path()];
        return spawn(GIT_EXEC, args, {
          stdio: [req, res, res]
        });
      }).then(function() {
        return next();
      })["catch"](next);
    });
    app.post(":git_repo(.*).git/git-receive-pack", app.authorize("receive-pack"), function(req, res, next) {
      var git_repo, pack, repo, repositories;
      res.set(headers("receive-pack"));
      repositories = req.git.repositories;
      git_repo = req.params.git_repo;
      repo = repositories.openOrInit(git_repo).then(function(arg) {
        var repo;
        repo = arg[0];
        return repo;
      });
      pack = new Promise(function(resolve, reject) {
        var git;
        git = new GitUpdateRequest();
        git.on("error", reject);
        git.on("changes", function() {
          git.removeListener("error", reject);
          return resolve(git);
        });
        return requestStream(req).pipe(git);
      });
      return Promise.join(repo, pack, function(repo, pack) {
        var capabilities, changeline, changes;
        capabilities = pack.capabilities, changes = pack.changes;
        changeline = function(arg) {
          var after, before, line, ref;
          before = arg.before, after = arg.after, ref = arg.ref;
          line = [before, after, ref].join(" ");
          if (capabilities) {
            line = line + "\0" + capabilities;
            capabilities = null;
          }
          return pktline(line + "\n");
        };
        return app.emit("pre-receive", repo, changes).then(function() {
          return Promise.map(changes, function(change, i) {
            return app.emit("update", repo, change).then(function() {
              return change;
            })["catch"](function() {
              return null;
            });
          });
        }).then(function(changes) {
          var c, change, git, j, len, ref3, stderr, stdin, stdout;
          changes = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = changes.length; j < len; j++) {
              c = changes[j];
              if (c != null) {
                results.push(c);
              }
            }
            return results;
          })();
          if (!(changes.length > 0)) {
            return;
          }
          git = spawn(GIT_EXEC, ["receive-pack", "--stateless-rpc", repo.path()]);
          ref3 = git.process, stdin = ref3.stdin, stdout = ref3.stdout, stderr = ref3.stderr;
          stdout.pipe(res, {
            end: false
          });
          stderr.pipe(res, {
            end: false
          });
          for (j = 0, len = changes.length; j < len; j++) {
            change = changes[j];
            stdin.write(changeline(change));
          }
          stdin.write(ZERO_PKT_LINE);
          pack.pipe(stdin);
          return git;
        }).then(function() {
          return app.emit("post-receive", repo, changes);
        });
      })["finally"](function() {
        return res.end();
      }).then(function() {
        return next();
      })["catch"](next);
    });
    return app.get("/:git_repo(.*).git/info/refs", app.authorize("advertise-refs"), function(req, res, next) {
      var git_repo, repositories, service;
      service = req.query.service;
      if (service !== "git-receive-pack" && service !== "git-upload-pack") {
        return next(new BadRequestError);
      }
      service = service.replace("git-", "");
      repositories = req.git.repositories;
      git_repo = req.params.git_repo;
      return repositories.openOrInit(git_repo).then(function(arg) {
        var args, repo;
        repo = arg[0];
        res.set(headers(service, "advertisement"));
        res.write(pktline("# service=git-" + service + "\n"));
        res.write(ZERO_PKT_LINE);
        args = [service, "--stateless-rpc", "--advertise-refs", repo.path()];
        return spawn(GIT_EXEC, args, {
          stdio: ["ignore", res, "pipe"]
        });
      }).then(function() {
        return next();
      })["catch"](next);
    });
  };

}).call(this);


