// Generated by CoffeeScript 1.12.7
(function() {
  var Busboy, Promise, _path, createWriteStream, git, httpify, key, mkdirp, processCommitForm, ref1, ref2, rimraf, value, workdir,
    hasProp = {}.hasOwnProperty;

  Busboy = require("busboy");

  Promise = require("bluebird");

  _path = require("path");

  ref1 = require("../helpers"), workdir = ref1.workdir, httpify = ref1.httpify;

  createWriteStream = require("fs").createWriteStream;

  rimraf = Promise.promisify(require("rimraf"));

  mkdirp = Promise.promisify(require("mkdirp"));

  git = require("../ezgit");

  processCommitForm = function(req, workdir, path) {
    var add, bb, commit, files, form, remove;
    bb = new Busboy({
      headers: req.headers
    });
    files = [];
    add = [];
    bb.on("file", function(filepath, file) {
      var dest;
      filepath = _path.join(path || "", filepath);
      dest = _path.join(workdir, filepath);
      return files.push((mkdirp(_path.dirname(dest))).then(function() {
        return new Promise(function(resolve, reject) {
          file.on("end", function() {
            add.push(filepath);
            return resolve();
          });
          file.on("error", reject);
          return file.pipe(createWriteStream(dest));
        });
      }));
    });
    commit = {};
    remove = [];
    bb.on("field", function(fieldname, value) {
      if (fieldname === "remove") {
        return remove.push(value);
      } else {
        return commit[fieldname] = value;
      }
    });
    form = new Promise(function(resolve) {
      return bb.on("finish", function() {
        return Promise.all(files).then(function() {
          return resolve({
            add: add,
            remove: remove,
            commit: commit
          });
        });
      });
    });
    req.pipe(bb);
    return form;
  };

  module.exports = function(app, options) {
    var BadRequestError, ConflictError, ref2;
    ref2 = app.errors, ConflictError = ref2.ConflictError, BadRequestError = ref2.BadRequestError;
    return app.post("/:git_repo(.*).git/:refname(.*)?/commit/:path(.*)?", app.authorize("commit"), function(req, res, next) {
      var WORKDIR, addremove, author, committer, disposable, etag, form, git_repo, index, parent, path, ref, ref3, ref4, ref5, refname, repo, repositories, tree;
      ref3 = req.params, git_repo = ref3.git_repo, refname = ref3.refname, path = ref3.path;
      ref4 = req.git, repositories = ref4.repositories, disposable = ref4.disposable;
      etag = req.headers['x-parent-id'] || ((ref5 = req.query) != null ? ref5.parent : void 0) || ("" + git.Oid.ZERO);
      WORKDIR = workdir();
      form = processCommitForm(req, WORKDIR, path);
      repo = repositories.openOrInit(git_repo).then(function(arg) {
        var repo;
        repo = arg[0];
        return repo;
      });
      ref = repo.then(function(repo) {
        if (refname == null) {
          refname = "HEAD";
        }
        return git.Reference.find(repo, refname).then(disposable)["catch"](httpify(404)).then(function(ref) {
          if (ref != null ? ref.isSymbolic() : void 0) {
            refname = ref.symbolicTarget();
            ref = null;
          } else if (ref != null) {
            refname = ref.name();
          }
          if ((ref != null) && ("" + (ref.target())) !== etag) {
            throw new ConflictError;
          }
          return ref;
        });
      });
      parent = Promise.join(repo, ref, function(repo, ref) {
        if (ref != null) {
          return disposable(repo.getCommit(ref.target()));
        } else {
          return null;
        }
      });
      tree = parent.then(function(parent) {
        return parent != null ? parent.getTree().then(disposable).then(function(tree) {
          if (!path) {
            return tree;
          }
          return tree != null ? tree.entryByPath(path).then(disposable).then(function(entry) {
            if (entry.isBlob()) {
              throw new BadRequestError("Entry is not a blob");
            }
            return tree;
          }) : void 0;
        }) : void 0;
      });
      index = Promise.join(repo, tree, function(repo, tree) {
        return repo.index().then(disposable).then(function(index) {
          index.clear();
          if (tree) {
            index.readTree(tree);
          }
          return index;
        });
      });
      disposable(author = Promise.join(repo, form, function(repo, arg) {
        var commit, created_at;
        commit = arg.commit;
        created_at = commit.created_at, author = commit.author;
        if (author) {
          return git.Signature.create(author, new Date(created_at));
        } else {
          return repo.defaultSignature();
        }
      }));
      disposable(committer = Promise.join(author, form, function(author, arg) {
        var commit;
        commit = arg.commit;
        committer = commit.committer;
        if (committer) {
          return git.Signature.create(committer, new Date());
        } else {
          return git.Signature.create(author, new Date());
        }
      }));
      addremove = Promise.join(repo, index, form, function(repo, index, arg) {
        var a, add, i, j, len, len1, r, remove;
        remove = arg.remove, add = arg.add;
        repo.setWorkdir(WORKDIR, 0);
        for (i = 0, len = remove.length; i < len; i++) {
          r = remove[i];
          index.removeByPath(r);
        }
        for (j = 0, len1 = add.length; j < len1; j++) {
          a = add[j];
          index.addByPath(a);
        }
        return index.writeTree().then(disposable);
      });
      return Promise.all([repo, form, author, committer, parent, addremove]).then(function(arg) {
        var author, commit, committer, form, parent, repo, tree;
        repo = arg[0], form = arg[1], author = arg[2], committer = arg[3], parent = arg[4], tree = arg[5];
        commit = {
          parents: parent ? ["" + (parent.id())] : [],
          ref: refname,
          tree: "" + tree,
          author: author.toJSON(),
          committer: committer.toJSON(),
          message: form.commit.message
        };
        return app.emit("pre-commit", repo, commit).then(function() {
          return repo.commit(commit);
        }).then(disposable).then(function(result) {
          commit.id = "" + (result.id());
          return app.emit("post-commit", repo, commit).then(function() {
            return result;
          });
        }).then(function(commit) {
          return res.json(commit);
        });
      })["finally"](function() {
        return rimraf(WORKDIR);
      }).then(function() {
        return next();
      })["catch"](next);
    });
  };

  ref2 = {
    processCommitForm: processCommitForm
  };
  for (key in ref2) {
    if (!hasProp.call(ref2, key)) continue;
    value = ref2[key];
    module.exports[key] = value;
  }

}).call(this);


