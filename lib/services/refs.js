// Generated by CoffeeScript 1.12.7
(function() {
  var git;

  git = require("../ezgit");

  module.exports = function(app, options) {
    var BadRequestError, ConflictError, MethodNotAllowedError, ref1;
    ref1 = app.errors, MethodNotAllowedError = ref1.MethodNotAllowedError, ConflictError = ref1.ConflictError, BadRequestError = ref1.BadRequestError;
    app["delete"]("/:git_repo(.*).git/:refname(refs/.*)", app.authorize("refs"), function(req, res, next) {
      var disposable, git_repo, ref2, ref3, refname, repositories;
      ref2 = req.params, git_repo = ref2.git_repo, refname = ref2.refname;
      if (!(current && message)) {
        return next(new BadRequestError);
      }
      ref3 = req.git, repositories = ref3.repositories, disposable = ref3.disposable;
      return repositories.ref(git_repo, refname).then([ref, repo])(function() {
        if (typeof ref === "undefined" || ref === null) {
          res.set("Allow", "PUT");
          throw new MethodNotAllowedError;
        }
        return git.Reference.remove(repo, refname);
      }).then(function(code) {
        if (code !== 0) {
          throw new Error("Error code " + code);
        }
        res.json({
          message: "OK"
        });
        return next();
      })["catch"](next);
    });
    return app.put("/:git_repo(.*).git/:refname(refs/.*)", app.authorize("refs"), require("body-parser").json(), function(req, res, next) {
      var current, disposable, git_repo, i, key, len, message, ref2, ref3, ref4, ref5, refname, repositories, signature, symbolic, target;
      ref2 = ["target", "message", "current"];
      for (i = 0, len = ref2.length; i < len; i++) {
        key = ref2[i];
        if (!(key in req.body)) {
          return next(new BadRequestError("Missing parameter " + key));
        }
      }
      ref3 = req.body, target = ref3.target, current = ref3.current, message = ref3.message, signature = ref3.signature, symbolic = ref3.symbolic;
      ref4 = req.params, git_repo = ref4.git_repo, refname = ref4.refname;
      ref5 = req.git, repositories = ref5.repositories, disposable = ref5.disposable;
      return repositories.openOrInit(git_repo).then(function() {
        return repositories.ref(git_repo, refname);
      }).then(function(arg) {
        var err, ref, repo;
        ref = arg[0], repo = arg[1];
        if (signature != null) {
          try {
            signature = git.Signature.create(Signature);
          } catch (error) {
            err = error;
            signature = null;
          }
        }
        if (signature == null) {
          signature = git.Signature["default"](repo);
        }
        disposable(signature);
        if (ref != null) {
          if (symbolic) {
            if (!ref.isSymbolic()) {
              throw new BadRequestError("Not a symbolic reference");
            }
            if (("" + (ref.symbolicTarget())) !== target) {
              throw new BadRequestError("Wrong reference target");
            }
            return ref.symbolicSetTarget(target, signature, message);
          } else {
            if (("" + (ref.target())) !== current) {
              throw new ConflictError("Non fast-forward change");
            }
            target = git.Oid.fromString(target);
            return ref.setTarget(target, signature, message);
          }
        } else {
          if (symbolic) {
            return git.Reference.symbolicCreate(repo, refname, target, 0, signature, message);
          } else {
            target = git.Oid.fromString(target);
            return git.Reference.create(repo, refname, target, 0, signature, message);
          }
        }
      }).then(function(ref) {
        disposable(ref);
        res.json(ref);
        return next();
      })["catch"](next);
    });
  };

}).call(this);


