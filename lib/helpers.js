// Generated by CoffeeScript 1.12.7
(function() {
  var Promise, UnsupportedMediaTypeError, _path, assign, exec, os, ref, spawn, zlib,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  os = require("os");

  _path = require("path");

  ref = require("child_process"), spawn = ref.spawn, exec = ref.exec;

  Promise = require("bluebird");

  assign = function() {
    var base, j, key, len, obj, others, value;
    base = arguments[0], others = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (typeof base !== "object") {
      return base;
    }
    for (j = 0, len = others.length; j < len; j++) {
      obj = others[j];
      if (typeof obj === "object") {
        for (key in obj) {
          if (!hasProp.call(obj, key)) continue;
          value = obj[key];
          base[key] = value;
        }
      }
    }
    return base;
  };

  zlib = require("zlib");

  UnsupportedMediaTypeError = require("./errors").UnsupportedMediaTypeError;

  module.exports = {
    requestStream: function(req) {
      var encoding, length, ref1;
      encoding = ((ref1 = req.headers["content-encoding"]) != null ? ref1.toLowerCase() : void 0) || "identity";
      length = req.headers["content-length"];
      switch (encoding) {
        case "deflate":
          return req.pipe(zlib.createInflate());
        case "gzip":
          return req.pipe(zlib.createGunzip());
        case "identity":
          req.length = length;
          return req;
        default:
          throw new UnsupportedMediaTypeError("Unsuported encoding " + encoding);
      }
    },
    assign: assign,
    a2o: function(arr) {
      return (function() {
        return arguments;
      }).apply(null, arr);
    },
    freeze: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      args.unshift({});
      return Object.freeze(assign.apply(null, args));
    },
    exec: Promise.promisify(exec),
    isMiddleware: function(m) {
      return typeof m === "function" || m instanceof express.Router || m instanceof express.Application;
    },
    spawn: function() {
      var args, cp, exit, i, j, len, ref1, ref2, s, stdio, str;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args[2] != null) {
        stdio = ((ref1 = args[2]) != null ? ref1.stdio : void 0) || null;
        delete args[2].stdio;
      } else {
        stdio = null;
      }
      cp = spawn.apply(null, args);
      if (stdio != null) {
        ref2 = ["stdin", "stdout", "stderr"];
        for (i = j = 0, len = ref2.length; j < len; i = ++j) {
          s = ref2[i];
          switch (stdio[i]) {
            case "pipe":
              str = process[s];
              break;
            case "ignore":
            case null:
            case false:
            case void 0:
              continue;
            default:
              str = stdio[i];
          }
          if (i > 0) {
            cp[s].pipe(str);
          } else {
            str.pipe(cp[s]);
          }
        }
      }
      exit = new Promise(function(resolve, reject) {
        return cp.on("exit", function(code) {
          if (code === 0) {
            return resolve();
          } else {
            return reject(new Error("Child process exited with code " + code));
          }
        });
      });
      exit.process = cp;
      return exit;
    },
    pktline: function(line) {
      var head, size;
      size = line.length + 4;
      head = ("0000" + (size.toString(16))).substr(-4, 4);
      return new Buffer("" + head + line);
    },
    httpify: function(status) {
      if (status == null) {
        status = 500;
      }
      return function(err) {
        if (err.status == null) {
          err.status = status;
        }
        throw err;
      };
    },
    workdir: function() {
      return _path.join(os.tmpdir(), "express-git-" + (new Date().getTime()));
    }
  };

}).call(this);


