// Generated by CoffeeScript 1.12.7
(function() {
  var DEFAULT_PATTERN, EventEmitter, Promise, RepoManager, _, _path, git, using,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require("lodash");

  Promise = require("bluebird");

  _path = require("path");

  git = require("./ezgit");

  EventEmitter = require("events-as-promised");

  using = function(handler, chain) {
    return git.using(chain, handler);
  };

  DEFAULT_PATTERN = /.*/;

  RepoManager = (function(superClass) {
    extend(RepoManager, superClass);

    module.exports = RepoManager;

    function RepoManager(root, disposables, options1) {
      this.root = root;
      this.disposables = disposables != null ? disposables : [];
      this.options = options1 != null ? options1 : {};
    }

    RepoManager.prototype.disposable = function(obj) {
      this.disposables.push(obj);
      return obj;
    };

    RepoManager.prototype.parse = function(path) {
      var match, name, pattern, ref1;
      name = path.replace(/\.git$/, "");
      pattern = ((ref1 = this.options) != null ? ref1.pattern : void 0) || DEFAULT_PATTERN;
      match = name.match(pattern);
      return Promise.resolve(match || []).then((function(_this) {
        return function(arg) {
          var git_dir, name, params;
          name = arg[0], params = 2 <= arg.length ? slice.call(arg, 1) : [];
          if (name == null) {
            throw new Error("Invalid repo path '" + path + "'");
          }
          git_dir = _path.join(_this.root, name);
          return [name, params, git_dir];
        };
      })(this));
    };

    RepoManager.prototype.ref = function(path, refname) {
      return this.open(path).then((function(_this) {
        return function(repo) {
          if (repo == null) {
            return [null, null];
          } else if (refname) {
            return repo.getReference(refname).then(_this.disposable).then(function(ref) {
              return [ref, repo];
            });
          } else {
            return repo.head().then(_this.disposable).then(function(ref) {
              return [ref, repo];
            });
          }
        };
      })(this));
    };

    RepoManager.prototype.openOrInit = function(path, options) {
      return this.open(path).then((function(_this) {
        return function(repo) {
          if (repo != null) {
            return [repo, false];
          } else if (_this.options.auto_init !== false) {
            return _this.init(path, options).then(function(repo) {
              return [repo, true];
            });
          } else {
            return [null, false];
          }
        };
      })(this));
    };

    RepoManager.prototype.open = function(path) {
      return this.parse(path).then((function(_this) {
        return function(arg) {
          var git_dir, name, params;
          name = arg[0], params = arg[1], git_dir = arg[2];
          return git.Repository.open(git_dir, {
            bare: true,
            ceilings: [_this.root]
          }).then(function(repo) {
            return _.assign(repo, {
              name: name,
              params: params,
              git_dir: git_dir
            });
          }).catch(function(reasonForFailure) {
            console.log("line : 107 => repo-manager.js => reasonForFailure : " + reasonForFailure);
            return null;
          });
        };
      })(this));
    };

    RepoManager.prototype.init = function(path, options) {
      if (options == null) {
        options = {};
      }
      return this.parse(path).then((function(_this) {
        return function(arg) {
          var git_dir, init_options, name, params;
          name = arg[0], params = arg[1], git_dir = arg[2];
          init_options = _.assign({}, _this.options.init_options, options);
          return _this.emit("pre-init", name, params, init_options).then(function() {
            return git.Repository.init(git_dir, options);
          }).then(_this.disposable)["catch"](function() {
            return null;
          }).then(function(repo) {
            return _.assign(repo, {
              name: name,
              params: params,
              git_dir: git_dir
            });
          }).then(function(repo) {
            if (repo != null) {
              return _this.emit("post-init", repo).then(function() {
                return repo;
              });
            } else {
              return repo;
            }
          });
        };
      })(this));
    };

    RepoManager.prototype.blob = function(reponame, oid, handler) {
      return this.open(reponame).then((function(_this) {
        return function(repo) {
          return repo.getBlob(oid).then(_this.disposable).then(function(blob) {
            return [blob, repo];
          });
        };
      })(this));
    };

    RepoManager.prototype.entry = function(reponame, refname, path, handler) {
      return this.commit(reponame, refname).then(function(arg) {
        var commit, ref, repo;
        commit = arg[0], ref = arg[1], repo = arg[2];
        if (commit == null) {
          return [null, null, null, null];
        }
        return commit.getEntry(path).then(this.disposable).then(function(entry) {
          return [entry, commit, ref, repo];
        });
      });
    };

    RepoManager.prototype.commit = function(reponame, refname, handler) {
      return this.ref(reponame, refname).then((function(_this) {
        return function(arg) {
          var ref, repo;
          ref = arg[0], repo = arg[1];
          if (repo == null) {
            return [null, null, null];
          }
          return repo.getCommit(ref.target()).then(_this.disposable).then(function(commit) {
            return [commit, ref, repo];
          });
        };
      })(this));
    };

    return RepoManager;

  })(EventEmitter);

}).call(this);

